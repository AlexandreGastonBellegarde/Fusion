

// data structure of Particles/Vertices
struct PointElement {
	// TODO: change the Point Element structure when needed
	float3 worldPosition;
	float3 worldVelocity;
	float invMass;
};

//struct PointPositionInt {
//	// TODO: change the Point Element structure when needed
//	int intPosX;
//	int intPosY;
//	int intPosZ;
//};

struct DeltaPos
{
	float deltaX;
	float deltaY;
	float deltaZ;
};

struct LineElement
{
	int startIndex;
	int endIndex;
};

struct DistanceConstraintStruct
{
	LineElement edge;
	float restLength;
	float weight;
};

StructuredBuffer<DistanceConstraintStruct> distanceConstraintData;
RWStructuredBuffer<PointElement> pointElements;
RWStructuredBuffer<DeltaPos> deltaPos;
RWStructuredBuffer<uint3> deltaPosASInt;
RWStructuredBuffer<int> deltaCount;

int numVertices;
int numEdges;
int numIterations;

// atomic add functions for delta X
void AtomicAddDeltaX(int indexIntoDeltaPos, float newDeltaValX)
{
	uint i_val = asuint(newDeltaValX);

	uint tmp0 = 0;

	uint tmp1;

	//uint deltaPosXUint = asuint(deltaPos[indexIntoDeltaPos].deltaX);

	[allow_uav_condition]while (true) {
		//InterlockedCompareExchange(0, tmp0, i_val, tmp1);
		InterlockedCompareExchange(deltaPosASInt[indexIntoDeltaPos].x, tmp0, i_val, tmp1);


		if (tmp1 == tmp0)
			break;

		tmp0 = tmp1;

		i_val = asuint(newDeltaValX + asfloat(tmp1));
	}
	return;
}

// atomic add functions for delta Y
void AtomicAddDeltaY(int indexIntoDeltaPos, float newDeltaValY)
{
	uint i_val = asuint(newDeltaValY);

	uint tmp0 = 0;

	uint tmp1;

	[allow_uav_condition]while (true) {
		InterlockedCompareExchange(deltaPosASInt[indexIntoDeltaPos].y),  tmp0, i_val, tmp1);

		if (tmp1 == tmp0)
			break;

		tmp0 = tmp1;

		i_val = asuint(newDeltaValY + asfloat(tmp1));
	}
	return;
}

// atomic add functions for delta Z
void AtomicAddDeltaZ(int indexIntoDeltaPos, float newDeltaValZ)
{
	uint i_val = asuint(newDeltaValZ);

	uint tmp0 = 0;

	uint tmp1;

	[allow_uav_condition]while (true) {
		InterlockedCompareExchange(deltaPosASInt[indexIntoDeltaPos].z, tmp0, i_val, tmp1);

		if (tmp1 == tmp0)
			break;

		tmp0 = tmp1;

		i_val = asuint(newDeltaValZ + asfloat(tmp1));
	}
	
	return;
}

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

//RWTexture2D<float4> Result;



#pragma kernel CalculateDeltas
[numthreads(8, 1, 1)]
void CalculateDeltas(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numEdges) return;
	// read current distance constraint
	DistanceConstraintStruct d = distanceConstraintData[id.x];
	// read the edge: start and end index
	LineElement l = d.edge;
	int startIndex = l.startIndex;
	int endIndex = l.endIndex;
	float restLength = d.restLength;
	float weight = d.weight;

	// atomic add the number of constraints to deltaCount buffer
	InterlockedAdd(deltaCount[startIndex], 1);
	InterlockedAdd(deltaCount[endIndex], 1);

	// Calculate Deltas
	// get positions
	float3 pi = pointElements[startIndex].worldPosition;
	float3 pj = pointElements[endIndex].worldPosition;
	// make edge vector
	float3 n = pi - pj;
	// get current length
	float L = length(n);

	// normalize edge vector
	if (L >= 1e-7) {
		n = normalize(n);
	}
	float wi = 1.0f;
	float wj = 1.0f;

	float3 deltaPosPI = -weight * wi/ (wi + wj) * (L - restLength) * n; //Minus
	float3 deltaPosPJ = weight * wj/ (wi + wj) * (L - restLength) * n; //Plus

	AtomicAddDeltaX(startIndex, deltaPosPI.x);
	AtomicAddDeltaY(startIndex, deltaPosPI.y);
	AtomicAddDeltaZ(startIndex, deltaPosPI.z);

	AtomicAddDeltaX(endIndex, deltaPosPJ.x);
	AtomicAddDeltaY(endIndex, deltaPosPJ.y);
	AtomicAddDeltaZ(endIndex, deltaPosPJ.z);

	//InterlockedAdd(pointPositionsInt[startIndex].intPosX, (int)(F_TO_I *deltaPosPI[0]));
	//InterlockedAdd(pointPositionsInt[startIndex].intPosY, (int)(F_TO_I *deltaPosPI[1]));
	//InterlockedAdd(pointPositionsInt[startIndex].intPosZ, (int)(F_TO_I *deltaPosPI[2]));

	//InterlockedAdd(pointPositionsInt[endIndex].intPosX, (int)(F_TO_I *deltaPosPJ[0]));
	//InterlockedAdd(pointPositionsInt[endIndex].intPosY, (int)(F_TO_I *deltaPosPJ[1]));
	//InterlockedAdd(pointPositionsInt[endIndex].intPosZ, (int)(F_TO_I *deltaPosPJ[2]));
}


#pragma kernel AveragingDeltas
[numthreads(8, 1, 1)]
void AveragingDeltas(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numVertices)return;
	if (deltaCount[id.x] > 0) {
		deltaPos[id.x].deltaX /= deltaCount[id.x];
		deltaPos[id.x].deltaY /= deltaCount[id.x];
		deltaPos[id.x].deltaZ /= deltaCount[id.x];
	}
	pointElements[id.x].worldPosition.x += deltaPos[id.x].deltaX * 10.0f;
	pointElements[id.x].worldPosition.y += deltaPos[id.x].deltaY * 10.0f;
	pointElements[id.x].worldPosition.z += deltaPos[id.x].deltaZ * 10.0f;
	
	// reset deltaPos buffer to zero
	deltaPos[id.x].deltaX = 0.0f;
	deltaPos[id.x].deltaY = 0.0f;
	deltaPos[id.x].deltaZ = 0.0f;
}

#pragma kernel CleanIntDeltas
[numthreads(8,1,1)]
void CleanIntDeltas(uint3 id: SV_DispatchThreadId) {
	if (id.x >= numVertices)return;
	deltaPosASInt[id.x] = { 0,0,0 };
}