

// data structure of Particles/Vertices
struct PointElement {
	// TODO: change the Point Element structure when needed
	float3 worldPosition;
	float3 worldVelocity;
	float invMass;
};

//struct PointPositionInt {
//	// TODO: change the Point Element structure when needed
//	int intPosX;
//	int intPosY;
//	int intPosZ;
//};

struct DeltaPos
{
	float deltaX;
	float deltaY;
	float deltaZ;
};

struct LineElement
{
	int startIndex;
	int endIndex;
};

struct DistanceConstraintStruct
{
	LineElement edge;
	float restLength;
	float weight;
};

StructuredBuffer<DistanceConstraintStruct> distanceConstraintData;
RWStructuredBuffer<PointElement> pointElements;
RWStructuredBuffer<PointElement> pointElements_Old;
RWStructuredBuffer<DeltaPos> deltaPos;
RWStructuredBuffer<uint3> deltaPosASInt;
RWStructuredBuffer<int> deltaCount;

int numVertices;
int numEdges;
int numIterations;

float radius;
float3 center;

// atomic add functions for delta X
void AtomicAddDeltaX(int indexIntoDeltaPos, float newDeltaValX)
{
	uint i_val = asuint(newDeltaValX);

	uint tmp0 = 0;

	uint tmp1;

	//uint deltaPosXUint = asuint(deltaPos[indexIntoDeltaPos].deltaX);

	[allow_uav_condition]while (true) {
		//InterlockedCompareExchange(0, tmp0, i_val, tmp1);
		InterlockedCompareExchange(deltaPosASInt[indexIntoDeltaPos].x, tmp0, i_val, tmp1);


		if (tmp1 == tmp0)
			break;

		tmp0 = tmp1;

		i_val = asuint(newDeltaValX + asfloat(tmp1));
	}
	return;
}

// atomic add functions for delta Y
void AtomicAddDeltaY(int indexIntoDeltaPos, float newDeltaValY)
{
	uint i_val = asuint(newDeltaValY);

	uint tmp0 = 0;

	uint tmp1;

	[allow_uav_condition]while (true) {
		InterlockedCompareExchange(deltaPosASInt[indexIntoDeltaPos].y,  tmp0, i_val, tmp1);

		if (tmp1 == tmp0)
			break;

		tmp0 = tmp1;

		i_val = asuint(newDeltaValY + asfloat(tmp1));
	}
	return;
}

// atomic add functions for delta Z
void AtomicAddDeltaZ(int indexIntoDeltaPos, float newDeltaValZ)
{
	uint i_val = asuint(newDeltaValZ);

	uint tmp0 = 0;

	uint tmp1;

	[allow_uav_condition]while (true) {
		InterlockedCompareExchange(deltaPosASInt[indexIntoDeltaPos].z, tmp0, i_val, tmp1);

		if (tmp1 == tmp0)
			break;

		tmp0 = tmp1;

		i_val = asuint(newDeltaValZ + asfloat(tmp1));
	}
	
	return;
}

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

//RWTexture2D<float4> Result;



#pragma kernel CalculateDeltas
[numthreads(8, 1, 1)]
void CalculateDeltas(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numEdges + numVertices) return;

	if (id.x < numEdges) 
	{
		// read current distance constraint
		DistanceConstraintStruct d = distanceConstraintData[id.x];
		// read the edge: start and end index
		LineElement l = d.edge;
		int startIndex = l.startIndex;
		int endIndex = l.endIndex;
		float restLength = d.restLength;
		float weight = d.weight;

		// atomic add the number of constraints to deltaCount buffer
		InterlockedAdd(deltaCount[startIndex], 1);
		InterlockedAdd(deltaCount[endIndex], 1);

		// Calculate Deltas
		// get positions
		float3 pi = pointElements[startIndex].worldPosition;
		float3 pj = pointElements[endIndex].worldPosition;
		// make edge vector
		float3 n = pi - pj;
		// get current length
		float L = length(n);

		// normalize edge vector
		if (L >= 1e-7) {
			n = normalize(n);
		}
		float wi = 1.0f;
		float wj = 1.0f;

		float3 deltaPosPI = -weight * wi / (wi + wj) * (L - restLength) * n; //Minus
		float3 deltaPosPJ = weight * wj / (wi + wj) * (L - restLength) * n; //Plus

		AtomicAddDeltaX(startIndex, deltaPosPI.x);
		AtomicAddDeltaY(startIndex, deltaPosPI.y);
		AtomicAddDeltaZ(startIndex, deltaPosPI.z);

		AtomicAddDeltaX(endIndex, deltaPosPJ.x);
		AtomicAddDeltaY(endIndex, deltaPosPJ.y);
		AtomicAddDeltaZ(endIndex, deltaPosPJ.z);
		return;
	}
	//else
	//{
	//	InterlockedAdd(deltaCount[id.x - numEdges], 1);

	//	PointElement p = pointElements[id.x - numEdges];
	//	PointElement p_old = pointElements_Old[id.x - numEdges];
	//	float3 pos = p_old.worldPosition;
	//	float3 projectedPos = p.worldPosition;
	//	// get collision pos and normals

	//	float3 direction = normalize(projectedPos - pos);
	//	// L is the distance from original point to the center
	//	float L = length(center - pos);
	//	// tc is the distance from original point to the center's
	//	// projected point on the ray
	//	float tc = dot(center - pos, direction);
	//	// d is the closest distance from center to the ray
	//	float d = sqrt(L * L - tc * tc);
	//	// tc1 is the distance from the collision point to the center's
	//	// projected point on the ray
	//	float tc1 = sqrt(radius * radius - d * d);
	//	// t is the distance from original position to the collision point
	//	float t = tc - tc1;

	//	float3 collisionPos = pos + direction * t;
	//	float3 normal = normalize(collisionPos - center);

	//	float cp = dot(projectedPos - collisionPos, normal);

	//	if (cp < 0) { // constraint violated. project the constraint
	//				  // n is the normal of the closest point on the sphere's surface to p
	//		float3 n = normalize(projectedPos - center);
	//		// q is the closest point on the sphere's surface to p
	//		float3 q = center + n * radius;

	//		float3 delta = q - projectedPos;
	//		AtomicAddDeltaX(id.x - numEdges, delta.x);
	//		AtomicAddDeltaY(id.x - numEdges, delta.y);
	//		AtomicAddDeltaZ(id.x - numEdges, delta.z);		
	//	}
	//}
	
}


#pragma kernel AveragingDeltas
[numthreads(8, 1, 1)]
void AveragingDeltas(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numVertices)return;
	if (deltaCount[id.x] > 0) {
		deltaPos[id.x].deltaX = asfloat(deltaPosASInt[id.x].x);
		deltaPos[id.x].deltaY = asfloat(deltaPosASInt[id.x].y);
		deltaPos[id.x].deltaZ = asfloat(deltaPosASInt[id.x].z);

		deltaPos[id.x].deltaX /= deltaCount[id.x];
		deltaPos[id.x].deltaY /= deltaCount[id.x];
		deltaPos[id.x].deltaZ /= deltaCount[id.x];
	}
	pointElements[id.x].worldPosition.x += deltaPos[id.x].deltaX * 2.0f;
	pointElements[id.x].worldPosition.y += deltaPos[id.x].deltaY * 2.0f;
	pointElements[id.x].worldPosition.z += deltaPos[id.x].deltaZ * 2.0f;
	
	// reset deltaPos buffer to zero
	deltaPos[id.x].deltaX = 0.0f;
	deltaPos[id.x].deltaY = 0.0f;
	deltaPos[id.x].deltaZ = 0.0f;

	deltaPosASInt[id.x].x = 0;
	deltaPosASInt[id.x].y = 0;
	deltaPosASInt[id.x].z = 0;

	deltaCount[id.x] = 0;
}

//#pragma kernel CleanIntDeltas
//[numthreads(8,1,1)]
//void CleanIntDeltas(uint3 id: SV_DispatchThreadId) {
//	if (id.x >= numVertices)return;
//	deltaPosASInt[id.x] = { 0,0,0 };
//}